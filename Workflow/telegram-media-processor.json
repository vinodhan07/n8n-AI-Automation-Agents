{
  "name": "Telegram Media Processor — Gemini + PostgreSQL",
  "nodes": [
    {
      "parameters": {
        "updateFields": {
          "botToken": "={{$credentials.telegramBot.token}}"
        },
        "triggerOn": [
          "message"
        ]
      },
      "name": "Telegram Trigger",
      "type": "n8n-nodes-base.telegramTrigger",
      "typeVersion": 1,
      "position": [250, 200]
    },
    {
      "parameters": {
        "functionCode": "/* Normalize Telegram message into common fields */\nconst msg = $json;\n// Telegram Trigger returns message in different paths; attempt common shapes\nconst message = msg.message || msg; \nconst chatId = (message.chat && message.chat.id) || message.chatId || null;\nconst fromId = (message.from && message.from.id) || null;\nconst caption = message.caption || message.text || '';\n\n// Identify media type and file_id\nlet media = null;\nif (message.photo) {\n  // photo is array of sizes - pick last\n  media = { type: 'photo', file_id: message.photo[message.photo.length-1].file_id };\n} else if (message.video) media = { type: 'video', file_id: message.video.file_id };\nelse if (message.audio) media = { type: 'audio', file_id: message.audio.file_id };\nelse if (message.voice) media = { type: 'audio', file_id: message.voice.file_id };\nelse if (message.document) media = { type: 'document', file_id: message.document.file_id, file_name: message.document.file_name };\nelse if (message.text) media = { type: 'text', text: message.text };\n\nreturn [{ json: { chatId, fromId, caption, media } }];"
      },
      "name": "Set Input",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [450, 200]
    },
    {
      "parameters": {
        "requestMethod": "POST",
        "url": "=https://api.telegram.org/bot{{$credentials.telegramBot.token}}/getFile",
        "jsonParameters": true,
        "bodyParametersJson": "={ \"file_id\": $json[\"media\"].file_id }"
      },
      "name": "Telegram - Get File Info",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 1,
      "position": [700, 200]
    },
    {
      "parameters": {
        "functionCode": "const resp = $node['Telegram - Get File Info'].json;\n// Telegram returns file_path at result.file_path\nconst filePath = resp.result && resp.result.file_path ? resp.result.file_path : null;\nif (!filePath) throw new Error('No file_path returned from Telegram getFile');\nconst downloadUrl = `https://api.telegram.org/file/bot${$credentials.telegramBot.token}/${filePath}`;\nreturn [{ json: { downloadUrl, media: $node['Set Input'].json.media, chatId: $node['Set Input'].json.chatId, caption: $node['Set Input'].json.caption } }];"
      },
      "name": "Build Download URL",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [900, 200]
    },
    {
      "parameters": {
        "requestMethod": "GET",
        "url": "={{ $json.downloadUrl }}",
        "responseFormat": "File",
        "options": {}
      },
      "name": "Download File",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 1,
      "position": [1150, 200]
    },
    {
      "parameters": {
        "functionCode": "/* route by media type */\nconst media = $node['Build Download URL'].json.media;\nif (!media) return [{ json: { action: 'none', reason: 'no media found' } }];\nconst type = media.type;\nreturn [{ json: { action: 'route', mediaType: type } }];"
      },
      "name": "Detect Media Type",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [1350, 200]
    },
    {
      "parameters": {
        "conditions": {
          "string": [
            { "value1": "={{$json[\"mediaType\"]}}", "operation": "equal", "value2": "photo" },
            { "value1": "={{$json[\"mediaType\"]}}", "operation": "equal", "value2": "video" },
            { "value1": "={{$json[\"mediaType\"]}}", "operation": "equal", "value2": "audio" },
            { "value1": "={{$json[\"mediaType\"]}}", "operation": "equal", "value2": "document" },
            { "value1": "={{$json[\"mediaType\"]}}", "operation": "equal", "value2": "text" }
          ]
        }
      },
      "name": "Switch - Media Type",
      "type": "n8n-nodes-base.switch",
      "typeVersion": 1,
      "position": [1550, 200]
    },

    {
      "parameters": {
        "requestMethod": "POST",
        "url": "https://api.openai.com/v1/responses",
        "headers": [
          { "name": "Authorization", "value": "Bearer {{ $credentials.openaiApiKey.apiKey }}" },
          { "name": "Content-Type", "value": "application/json" }
        ],
        "bodyParametersJson": "={\n  \"model\": \"gpt-4o-mini\", \n  \"input\": [\n    {\"role\":\"system\",\"content\":\"You are Gemini-style multimodal analyzer for media. You will be given a short description of the media and a link to download. Return a JSON object with keys: {metadata:{}, text: string|null, transcription: string|null, insights: [strings], tags:[strings]}. Return only JSON.\"},\n    {\"role\":\"user\",\"content\":\"Analyze this IMAGE at {{$node['Download File'].json[0].fileName || 'downloaded file'}} (downloadable URL provided by the workflow). Provide extracted text (if any), brief insights, suggested tags, and structured metadata (mime type, size). Use concise bullet-style insights.\"}\n  ],\n  \"temperature\": 0.0,\n  \"max_tokens\": 800\n}"
      },
      "name": "OpenAI - Analyze Image",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 1,
      "position": [1800, 80]
    },

    {
      "parameters": {
        "requestMethod": "POST",
        "url": "https://api.openai.com/v1/responses",
        "headers": [
          { "name": "Authorization", "value": "Bearer {{ $credentials.openaiApiKey.apiKey }}" },
          { "name": "Content-Type", "value": "application/json" }
        ],
        "bodyParametersJson": "={\n  \"model\": \"gpt-4o-mini\", \n  \"input\": [\n    {\"role\":\"system\",\"content\":\"You are a multimodal processor. For VIDEO: extract a short description of visual content, detect scenes, extract speech transcript if possible, and return insights. Return only JSON: {metadata:{}, transcription: string|null, insights:[...], tags:[...]}\"},\n    {\"role\":\"user\",\"content\":\"Analyze the provided video URL. Provide scene-level insights, notable actions, and suggested tags.\"}\n  ],\n  \"temperature\": 0.0,\n  \"max_tokens\": 1200\n}"
      },
      "name": "OpenAI - Analyze Video",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 1,
      "position": [1800, 200]
    },

    {
      "parameters": {
        "requestMethod": "POST",
        "url": "https://api.openai.com/v1/responses",
        "headers": [
          { "name": "Authorization", "value": "Bearer {{ $credentials.openaiApiKey.apiKey }}" },
          { "name": "Content-Type", "value": "application/json" }
        ],
        "bodyParametersJson": "={\n  \"model\": \"gpt-4o-mini\",\n  \"input\": [\n    {\"role\":\"system\",\"content\":\"You are a transcription and audio analyzer. For AUDIO: return transcription, summary (1-2 lines), notes, and tags as JSON.\"},\n    {\"role\":\"user\",\"content\":\"Transcribe and summarize the audio accessible at the provided URL. Return only JSON with fields {transcription, summary, tags, metadata}.\"}\n  ],\n  \"temperature\": 0.0,\n  \"max_tokens\": 1200\n}"
      },
      "name": "OpenAI - Analyze Audio",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 1,
      "position": [1800, 320]
    },

    {
      "parameters": {
        "requestMethod": "POST",
        "url": "https://api.openai.com/v1/responses",
        "headers": [
          { "name": "Authorization", "value": "Bearer {{ $credentials.openaiApiKey.apiKey }}" },
          { "name": "Content-Type", "value": "application/json" }
        ],
        "bodyParametersJson": "={\n  \"model\": \"gpt-4o-mini\",\n  \"input\": [\n    {\"role\":\"system\",\"content\":\"You are a document analyzer. For PDFs or documents: extract main text, summarize key points, list found entities (people/orgs/dates), and return metadata. Return only JSON.\"},\n    {\"role\":\"user\",\"content\":\"Analyze the document at provided URL. Return JSON: {text, summary, entities, metadata}.\"}\n  ],\n  \"temperature\": 0.0,\n  \"max_tokens\": 1200\n}"
      },
      "name": "OpenAI - Analyze Document",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 1,
      "position": [1800, 440]
    },

    {
      "parameters": {
        "operation": "insert",
        "schema": "",
        "table": "media_analysis",
        "columns": "={ [\n  { \"name\": \"chat_id\", \"value\": $json.chatId },\n  { \"name\": \"file_url\", \"value\": $node['Build Download URL'].json.downloadUrl },\n  { \"name\": \"media_type\", \"value\": $node['Detect Media Type'].json.mediaType },\n  { \"name\": \"caption\", \"value\": $node['Build Download URL'].json.caption },\n  { \"name\": \"analysis_json\", \"value\": JSON.stringify($json.analysis || $json) },\n  { \"name\": \"created_at\", \"value\": new Date().toISOString() }\n] }"
      },
      "name": "Postgres - Save Analysis",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 1,
      "position": [2100, 260]
    },

    {
      "parameters": {
        "functionCode": "/* Build a concise reply to the user */\nconst analysis = $node['Postgres - Save Analysis'].json || $json.analysis || {};\nconst mediaType = $node['Detect Media Type'].json.mediaType || 'media';\nlet summary = '';\nif ($node['OpenAI - Analyze Image'] && $node['OpenAI - Analyze Image'].json && mediaType === 'photo') {\n  try {\n    const text = $node['OpenAI - Analyze Image'].json;\n    // If the analyzer returned a JSON text field, attempt to parse\n    const parsed = typeof text === 'string' ? JSON.parse(text) : text;\n    summary = parsed.summary || parsed.insights ? parsed.insights.slice(0,3).join('; ') : 'Processed image.';\n  } catch (e) { summary = 'Image processed.'; }\n} else if (mediaType === 'audio' && $node['OpenAI - Analyze Audio']) {\n  try { const p = $node['OpenAI - Analyze Audio'].json; const parsed = typeof p === 'string' ? JSON.parse(p) : p; summary = parsed.summary || (parsed.transcription || '').slice(0,200) || 'Audio processed.'; } catch(e){ summary='Audio processed.'; }\n} else if (mediaType === 'video' && $node['OpenAI - Analyze Video']) {\n  summary = 'Video processed — insights saved.';\n} else if (mediaType === 'document' && $node['OpenAI - Analyze Document']) {\n  summary = 'Document processed — summary saved.';\n} else {\n  summary = 'Media processed and saved to database.';\n}\nreturn [{ json: { chatId: $node['Build Download URL'].json.chatId, text: `✅ Your ${mediaType} was processed. ${summary}` } }];"
      },
      "name": "Build Telegram Reply",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [2350, 260]
    },

    {
      "parameters": {
        "requestMethod": "POST",
        "url": "=https://api.telegram.org/bot{{$credentials.telegramBot.token}}/sendMessage",
        "jsonParameters": true,
        "bodyParametersJson": "={ \"chat_id\": $json.chatId, \"text\": $json.text }"
      },
      "name": "Telegram - Send Reply",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 1,
      "position": [2550, 260]
    },

    {
      "parameters": {
        "functionCode": "/* Generic parser: try to convert LLM text outputs into JSON and attach under field analysis */\nfunction tryParse(node) {\n  try {\n    const raw = node && node.json ? node.json : node;\n    if (!raw) return null;\n    if (typeof raw === 'string') return JSON.parse(raw);\n    if (raw.output_text) return JSON.parse(raw.output_text);\n    return raw;\n  } catch (e) { return raw; }\n}\n\nlet analysis = null;\nconst mediaType = $node['Detect Media Type'].json.mediaType;\nif (mediaType === 'photo') analysis = tryParse($node['OpenAI - Analyze Image']);\nelse if (mediaType === 'video') analysis = tryParse($node['OpenAI - Analyze Video']);\nelse if (mediaType === 'audio') analysis = tryParse($node['OpenAI - Analyze Audio']);\nelse if (mediaType === 'document') analysis = tryParse($node['OpenAI - Analyze Document']);\nelse analysis = { note: 'text or no media' };\n\nreturn [{ json: { analysis } }];"
      },
      "name": "Normalize Analysis",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [1950, 260]
    }
  ],
  "connections": {
    "Telegram Trigger": {
      "main": [[{ "node": "Set Input", "type": "main", "index": 0 }]]
    },
    "Set Input": {
      "main": [[{ "node": "Telegram - Get File Info", "type": "main", "index": 0 }]]
    },
    "Telegram - Get File Info": {
      "main": [[{ "node": "Build Download URL", "type": "main", "index": 0 }]]
    },
    "Build Download URL": {
      "main": [[{ "node": "Download File", "type": "main", "index": 0 }, { "node": "Detect Media Type", "type": "main", "index": 0 }]]
    },
    "Download File": {
      "main": [[{ "node": "Detect Media Type", "type": "main", "index": 0 }]]
    },
    "Detect Media Type": {
      "main": [
        [{ "node": "Switch - Media Type", "type": "main", "index": 0 }]
      ]
    },
    "Switch - Media Type": {
      "main": [
        [{ "node": "OpenAI - Analyze Image", "type": "main", "index": 0 }],
        [{ "node": "OpenAI - Analyze Video", "type": "main", "index": 0 }],
        [{ "node": "OpenAI - Analyze Audio", "type": "main", "index": 0 }],
        [{ "node": "OpenAI - Analyze Document", "type": "main", "index": 0 }],
        [{ "node": "Build Telegram Reply", "type": "main", "index": 0 }]
      ]
    },
    "OpenAI - Analyze Image": {
      "main": [[{ "node": "Normalize Analysis", "type": "main", "index": 0 }]]
    },
    "OpenAI - Analyze Video": {
      "main": [[{ "node": "Normalize Analysis", "type": "main", "index": 0 }]]
    },
    "OpenAI - Analyze Audio": {
      "main": [[{ "node": "Normalize Analysis", "type": "main", "index": 0 }]]
    },
    "OpenAI - Analyze Document": {
      "main": [[{ "node": "Normalize Analysis", "type": "main", "index": 0 }]]
    },
    "Normalize Analysis": {
      "main": [[{ "node": "Postgres - Save Analysis", "type": "main", "index": 0 }]]
    },
    "Postgres - Save Analysis": {
      "main": [[{ "node": "Build Telegram Reply", "type": "main", "index": 0 }]]
    },
    "Build Telegram Reply": {
      "main": [[{ "node": "Telegram - Send Reply", "type": "main", "index": 0 }]]
    }
  },
  "active": false,
  "settings": {}
}
